
import java.awt.Desktop;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

/*
 * NOTE: on line 166 
 * null pointer dereferenced has been uncheked from box on Netbeans Settings (->Options -> Editor -> uncheck Null Pointer Dereferenced)
 * TECHNICALITIES: 
 *
 * SEARCH button: note that I did not program the SEARCH button in a new Dialog Box. Instead I used a JOptionPane to get input for the string 
 * to search. Once user presses OK a JOptionPane.showMessageDialog(fram, lines of result). NOTE that multiple lines can be returned in the message box. 
 * Therefore, I must collect the lines to a variable arrayList* of String, to show the variable (i.e the lines) in the Message box. *ArrayList is used
 * because of the need to grow the array (as lines are found). (regular arrays cannot grow nor shwrink)
 * 
 * GET FILE button: note that the default file to be read/write is called passwordRepository.txt; NOTE that if the file is not in the given directory path
 * the program automatically creatres the file. If the file is there, the program only re-writes the file.
 */

/*
 * @author Nuno Spencer
 * www.nunospencer.com
 */

public class PassLock_Main extends javax.swing.JFrame {
    
    File file = new File("C:\\Users\\Nuno\\Documents\\my_passwords.txt"); // THIS WILL BE CHANGED TO location origianlly chosen by user
    
    
    //creates and displays the main frame
    public PassLock_Main() {  
        initComponents();
    }
    
   
    /**
     * method initComponents()
     * 
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        findBtn = new javax.swing.JButton();
        searchJtextField = new javax.swing.JTextField();
        addBtn = new javax.swing.JButton();
        getFileBtn = new javax.swing.JButton();
        randomizeBtn = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Passlock v1.0");
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setName("PasswordBrain_v1_MainWindow"); // NOI18N

        findBtn.setIcon(new javax.swing.ImageIcon(getClass().getResource("/magGlasssearch.png"))); // NOI18N
        findBtn.setToolTipText("Find password");
        findBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findBtnActionPerformed(evt);
            }
        });

        searchJtextField.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        searchJtextField.setToolTipText("Enter ACCOUNT associated with the password you wish to find, E.G. \"Facebook\" ");

        addBtn.setText("ADD NEW");
        addBtn.setToolTipText("Add new password");
        addBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addBtnActionPerformed(evt);
            }
        });

        getFileBtn.setText("GET FILE");
        getFileBtn.setToolTipText("Get your passwords");
        getFileBtn.setPreferredSize(new java.awt.Dimension(77, 23));
        getFileBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                getFileBtnActionPerformed(evt);
            }
        });

        randomizeBtn.setText("RANDOMIZE");
        randomizeBtn.setToolTipText("Gives a random password for you to use");
        randomizeBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                randomizeBtnActionPerformed(evt);
            }
        });

        jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/PasswordbrainIcon.png"))); // NOI18N
        jLabel1.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(30, 30, 30)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(searchJtextField)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(findBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(randomizeBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(getFileBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(addBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel1)))
                .addGap(30, 30, 30))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(30, 30, 30)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(findBtn, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(searchJtextField, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(addBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(getFileBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(randomizeBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(30, Short.MAX_VALUE))
        );

        if(searchJtextField.getText().equals(""))
        {
            findBtn.setEnabled(false);
        }else
        {
            findBtn.setEnabled(true);
        }
        searchJtextField.getDocument().addDocumentListener(new DocumentListener()
            {
                public void changedUpdate(DocumentEvent e)
                {
                    enableButton();
                }
                public void removeUpdate(DocumentEvent e)
                {
                    enableButton();
                }
                public void insertUpdate(DocumentEvent e)
                {
                    enableButton();
                }

                public void enableButton()
                {
                    if (searchJtextField.getText().equals(""))
                    {
                        findBtn.setEnabled(false);
                    }
                    else
                    {
                        findBtn.setEnabled(true);
                    }
                }
            });

            pack();
            setLocationRelativeTo(null);
        }// </editor-fold>//GEN-END:initComponents

    //GET FILE button, gets file (if exists)
    private void getFileBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_getFileBtnActionPerformed
        if(evt.getSource() == getFileBtn)
        {
            if(!(file.exists()))
                JOptionPane.showMessageDialog(null, "Click \"ADD NEW\" to add a password.", "No File Found!", JOptionPane.ERROR_MESSAGE);
            else 
            {
                JFileChooser getFile = new JFileChooser();
                int x = getFile.showOpenDialog(null);   
                if (x == JFileChooser.APPROVE_OPTION)
                    file = getFile.getSelectedFile();
                try{
                    Desktop.getDesktop().open(file);   
                }catch(IOException e){
                    System.out.println("Error processing File!");
                }
            }
        }
    }//GEN-LAST:event_getFileBtnActionPerformed

    //ADD NEW button, adds new password
    private void addBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addBtnActionPerformed
        ADD_dialogBox_v1 addBtnDialog = new ADD_dialogBox_v1(this, true);
        addBtnDialog.setLocationRelativeTo(null);
        addBtnDialog.setVisible(true);
    }//GEN-LAST:event_addBtnActionPerformed
    
    //FIND button, uses algorithm to search a array of 4 strings. At a givem line, return a[2] given a[0], i.e given an account (array pos 0), return password (array pos 2). The file will have n lines.
    private void findBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findBtnActionPerformed
        
        //Scanner scanner;   //scanner object scans the file
        //String collectedLines = null; //this is the line that contains the password the user is looking for. **** there may be +1 lines thus I have to return them all. 
        //String givenAccnt = null;
        //4th version of algorithm I tried to use userInfo array to obtain the password at userInfo[2], given an account at userInfo[0]. This dont work as the method containing declaration of userInfo is private and cannot be modified (locked by netbeans)
        //3rd version improved.... given account string, return the whole line containing such string. Note we may have more than 1 line, i.e more than 1 given account. all the lines will be displayed on a message dialog
        if (evt.getSource() == findBtn) {
            if(!(file.exists()))
            {
                JOptionPane.showMessageDialog(null, "Click \"ADD NEW\" to add a password.", "No File Found!", JOptionPane.ERROR_MESSAGE);
                searchJtextField.setText("");
            /*}else if()
            {
                check if textfield is empty.. if empty disable find button... if not, search will performed when user clicks search button
            }    */
            }
            else
            {
                //givenAccnt = JOptionPane.showInputDialog(null, "Enter ACCOUNT associated with password you wish to find: ","Search for a Password", JOptionPane.INFORMATION_MESSAGE);
                findPasswords();
            }
        }
        /*scanner = new Scanner(file);     //initialize scanner on file
        while(scanner.hasNextLine())     //while lines are being scanned
        {
        String getLine = scanner.nextLine();   //gets a string
        int i = getLine.indexOf(' ');   //find 1st space (note that each entry is separeted by a space)
        String accntToken = getLine.substring(0, i);    //gets the account (1st string in the line)
        if(accntToken == null ? givenAccnt == null : accntToken.equals(givenAccnt))
        {                                   //return the whole line, store each found line in variable collected lines
        }                                   //write collectedLines to the dialog
        //else display message dialog nothing found
        }*/ //Logger.getLogger(PassLock_Main.class.getName()).log(Level.SEVERE, null, ex);
        //JOptionPane.showMessageDialog(null, "Error processing file!", "ERROR!" ,JOptionPane.ERROR_MESSAGE);
        
        
        //3rd Version of the algorithm... works, but logic is wrong... looks like is displaying all "words" from each line sequentialy
        /*  try
        {
        scanner = new Scanner(file);     //initialize scanner on file
        while(scanner.hasNextLine())     //while lines are being scanned
        {
        String getLine = scanner.nextLine();   //gets a string
        int i = getLine.indexOf(' ');               //find 1st space (note that each entry is separeted by a space).
        String source = getLine.substring(0, i);    //get the source (1st string in the entry)
        if(source.equals(givenSource))              //if this source is the source user is searching...
        collectedLines = new StringBuilder().append(getLine).toString();        //get that whole line
        else
        JOptionPane.showMessageDialog(null, "No match found!", "Password Not Found", JOptionPane.ERROR_MESSAGE);    //if not, password was not found
        JOptionPane.showMessageDialog(null, collectedLines);
        }
        }catch (FileNotFoundException ex) {
        Logger.getLogger(PasswordBrain_v1_Main.class.getName()).log(Level.SEVERE, null, ex);
        }
         */
        
        // 2nd VERSION , better but still with logical error. The problem is that the loop is running the whole file .. I believe i must change the while loop to for loop
        /*while(scanner.hasNextLine())                    //i.e while the file has a next line, keep cycling NOTE:null pointer dereferenced has been uncheked from box on Netbeans Settings
        {
        String getLine = scanner.nextLine();
        int i = getLine.indexOf(' ');               //find 1st space (note that each entry is separeted by a space).
        String source = getLine.substring(0, i);    //get the source (1st string in the entry)
        if(source.equals(givenSource))              //if this source is the source user is searching...
        collectedLines = new StringBuilder().append(getLine).toString();        //get that whole line
        else
        JOptionPane.showMessageDialog(null, "No match found!", "Password Not Found", JOptionPane.ERROR_MESSAGE);    //if not, password was not found
        JOptionPane.showMessageDialog(null, collectedLines);
        }*/
        
        // ORIGINAL VERSION, with logical error
        //        while(scanner.hasNextLine())                    //i.e while the file has a next line, keep cycling NOTE:null pointer dereferenced has been uncheked from box on Netbeans Settings
        //        {
        //            final String getLine = scanner.nextLine();
        //            if(getLine.contains(givenSource))
        //                list.add(getLine);
        //              else JOptionPane.showMessageDialog(null, "No match found!", "Password Not Found", JOptionPane.ERROR_MESSAGE);
        //            //JOptionPane.showMessageDialog(null, list);
        //        }
        //        JOptionPane.showMessageDialog(null, list);
        // this block of code compiles, but gives wrong output:
        // Logical error: source names can also be contained in emails. Therefore it not only gives the line that has the password, but also other lines that
        //    contain the given word (source), i.e lines that I dont need.
        //    SOLUTION: Notice that when adding an entry, the first input is the source. Therefore, when searching, the given word (source) must match the first
        //    word of the line. If match, collect the line(s) ***(you can have more than one Faceboook account)*** into a string builder then show it in a Message
        //    dialog.
        //    ALTERNATIVELY, To gain control over the search, I need all entries to
        //    be structured in an arrayList. ***note only arrayList can grow in size*** Notice that when adding an entry, the first input is the source. Therefore,
        //    when searching, the given word (source) must match the arrayList[0] i.e the word at position 0. If there are +1 matches (we can have more than
        //    1 facebook account), collect the lines in a string builder formatted w/ n/ (where each line is below another). Then output the String builder
        //    to the MessageDialog
    }//GEN-LAST:event_findBtnActionPerformed

    //RANDOMIZE button, password randomizer
    private void randomizeBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_randomizeBtnActionPerformed
        RANDOMIZE_dialogBox_v1 randomizeBtnDialog = new RANDOMIZE_dialogBox_v1(this, true);
        randomizeBtnDialog.setLocationRelativeTo(null);
        randomizeBtnDialog.setVisible(true);
    }//GEN-LAST:event_randomizeBtnActionPerformed
      
    //method to find passwords
    private void findPasswords()
    {
        String collectedLines = null; //this is the line that contains the password the user is looking for. 
        //**** there may be +1 lines thus I have to return them all.*** must use ArrayList of strings (lines of strings) instead of Array
        String givenAccnt = searchJtextField.getText();
        String accntToken;
        String getLine;
        int i;   //delineator... gets the substring from 0 to i... i.e gets the 'account' (1st string in lines of password entries)
        int v;   //counter... everytime an account is matched and a line is collected to ArrayList, increase v... the pane will also display number of accounts found (i.e. v)
        
        try
        {
            Scanner scan = new Scanner(file);
            while(scan.hasNextLine())                       //while lines are being scanned ----- USE INSTEAD A FOR LOOP (MUST SEARCH WHOLE FILE)
            {
                getLine = scan.nextLine();                  //gets a line
                i = getLine.indexOf(" ");                   //finds index of 1st space " " on that line  (or try ' ')
                accntToken = getLine.substring(0, i);       //gets the account (1st string token in the line, after " ")
                //if(accntToken == null ? givenAccnt == null : accntToken.equals(givenAccnt))
                if(givenAccnt.equalsIgnoreCase(accntToken)) //if given input account equals the account on the line 
                {     
                                                            //append the line to the ArrayList collectedLines
                                                            //write collectedLines to the dialog
                                                            //increase counter
                
                }else
                {
                    JOptionPane.showMessageDialog(null, "No passwords found that match given account.", "Nothing found!", JOptionPane.INFORMATION_MESSAGE);
                }                                          
            }
        }catch (FileNotFoundException ex) 
        {
            Logger.getLogger(PassLock_Main.class.getName()).log(Level.SEVERE, null, ex);
            JOptionPane.showMessageDialog(null, "Error processing file!", "ERROR!" ,JOptionPane.ERROR_MESSAGE);
        }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(PassLock_Main.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new PassLock_Main().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addBtn;
    private javax.swing.JButton findBtn;
    private javax.swing.JButton getFileBtn;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JButton randomizeBtn;
    private javax.swing.JTextField searchJtextField;
    // End of variables declaration//GEN-END:variables
}
